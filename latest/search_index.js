var documenterSearchIndex = {"docs":
[{"location":"pages/toml/#TOML","page":"TOML","title":"TOML","text":"","category":"section"},{"location":"pages/toml/#Parsing","page":"TOML","title":"Parsing","text":"","category":"section"},{"location":"pages/toml/#Serde.ParToml.parse_toml","page":"TOML","title":"Serde.ParToml.parse_toml","text":"parse_toml(x::AbstractString) -> Dict{String,Any}\nparse_toml(x::Vector{UInt8}) -> Dict{String,Any}\n\nParses a TOML string x (or vector of UInt8) into a dictionary.\n\nExamples\n\njulia> toml = \"\"\"\n       tag = \"line\"\n       [[points]]\n       x = 1\n       y = 0\n       [[points]]\n       x = 2\n       y = 3\n       \"\"\";\n\njulia> parse_toml(toml)\nDict{String, Any} with 3 entries:\n  \"tag\"  => \"line\"\n  \"points\" => Any[Dict{String, Any}(\"y\"=>0, \"x\"=>1), Dict{String, Any}(\"y\"=>3, \"x\"=>2)]\n\n\n\n\n\n","category":"function"},{"location":"pages/toml/#Serde.ParToml.TomlSyntaxError","page":"TOML","title":"Serde.ParToml.TomlSyntaxError","text":"TomlSyntaxError <: Exception\n\nException thrown when a parse_toml fails due to incorrect TOML syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/toml/#Deserialization","page":"TOML","title":"Deserialization","text":"","category":"section"},{"location":"pages/toml/#Serde.DeToml.deser_toml","page":"TOML","title":"Serde.DeToml.deser_toml","text":"deser_toml(::Type{T}, x) -> T\n\nCreates a new object of type T and fill it with values from TOML formated string x (or vector of UInt8).\n\nSee also parse_toml.\n\nExamples\n\njulia> struct Point\n           x::Int64\n           y::Int64\n       end\n\njulia> struct MyPlot\n           tag::String\n           points::Vector{Point}\n       end\n\njulia> toml = \"\"\"\n       tag = \"line\"\n       [[points]]\n       x = 1\n       y = 0\n       [[points]]\n       x = 2\n       y = 3\n       \"\"\";\n\njulia> deser_toml(MyPlot, toml)\nMyPlot(\"line\", Point[Point(1, 0), Point(2, 3)])\n\n\n\n\n\n","category":"function"},{"location":"pages/toml/#Serialization","page":"TOML","title":"Serialization","text":"","category":"section"},{"location":"pages/toml/#Serde.SerToml.to_toml","page":"TOML","title":"Serde.SerToml.to_toml","text":"to_toml(data) -> String\n\nPasses a dictionary data (or custom data structure) for making TOML string.\n\nExamples\n\nMake TOML string from nested dictionaries.\n\njulia> data = Dict(\n           \"points\" => [\n               Dict(\"x\" => \"100\", \"y\" => 200),\n               Dict(\"x\" => 300, \"y\" => 400),\n           ],\n           \"data\" => Dict(\"id\" => 321, \"price\" => 600),\n           \"answer\" => 42,\n       );\n\njulia> to_toml(data) |> println\nanswer = 42\n\n[data]\nprice = 600\nid = 321\n\n[[points]]\ny = 200\nx = \"100\"\n\n[[points]]\ny = 400\nx = 300\n\nMake TOML string from custom data structures.\n\njulia> struct Point\n           x::Int64\n           y::Int64\n       end\n\njulia> struct MyPlot\n           tag::String\n           points::Vector{Point}\n       end\n\njulia> myline = MyPlot(\"line\", Point[Point(1, 0), Point(2, 3)]);\n\njulia> to_toml(myline) |> println\ntag = \"line\"\n\n[[points]]\nx = 1\ny = 0\n\n[[points]]\nx = 2\ny = 3\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#JSON","page":"JSON","title":"JSON","text":"","category":"section"},{"location":"pages/json/#Parsing","page":"JSON","title":"Parsing","text":"","category":"section"},{"location":"pages/json/#Serde.ParJson.parse_json","page":"JSON","title":"Serde.ParJson.parse_json","text":"parse_json(x::AbstractString; kw...) -> Dict{String,Any}\nparse_json(x::Vector{UInt8}; kw...) -> Dict{String,Any}\n\nParse a JSON string x (or vector of UInt8) into a dictionary.\n\nKeyword arguments\n\nYou can see additional keyword arguments in JSON.jl package documentation.\n\nExamples\n\njulia> json = \"\"\"\n        {\n            \"number\": 123,\n            \"vector\": [1, 2, 3],\n            \"dictionary\":\n            {\n                \"string\": \"123\"\n            }\n        }\n       \"\"\";\n\njulia> parse_json(json)\nDict{String, Any} with 3 entries:\n  \"number\"     => 123\n  \"vector\"     => Any[1, 2, 3]\n  \"dictionary\" => Dict{String, Any}(\"string\"=>\"123\")\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serde.ParJson.JsonSyntaxError","page":"JSON","title":"Serde.ParJson.JsonSyntaxError","text":"JsonSyntaxError <: Exception\n\nException thrown when a parse_json fails due to incorrect JSON syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/json/#Deserialization","page":"JSON","title":"Deserialization","text":"","category":"section"},{"location":"pages/json/#Serde.DeJson.deser_json","page":"JSON","title":"Serde.DeJson.deser_json","text":"deser_json(::Type{T}, x; kw...) -> T\n\nCreates a new object of type T and fill it with values from JSON formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_json.\n\nExamples\n\njulia> struct Record\n           count::Float64\n       end\n\njulia> struct Data\n           id::Int64\n           name::String\n           body::Record\n       end\n\njulia> json = \"\"\" {\"body\":{\"count\":100.0},\"name\":\"json\",\"id\":100} \"\"\";\n\njulia> deser_json(Data, json)\nData(100, \"json\", Record(100.0))\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serialization","page":"JSON","title":"Serialization","text":"","category":"section"},{"location":"pages/json/#Serde.SerJson.to_json","page":"JSON","title":"Serde.SerJson.to_json","text":"to_json([f::Function], data) -> String\n\nSerializes any data into a flat JSON string. This method support serialization of nested data like dictionaries or custom types.\n\nSpecifying fields for serialization\n\nIf you want to serialize only specific fields of some custom type, you may define a special function f. This function f must lead next signature:\n\nf(::Type{CustomType}) = (:field_1, :field_2, ...)\n\nNow to_json(f, CustomType(...)) will serialize only specified fields CustomType.field_1, CustomType.field_2, etc. You can also define multiple methods of f for nested custom data types, e.g:\n\n# Custom type 'Foo' containing fields of other custom types 'bar::Bar' and 'baz::Baz'\ncustom_field_names(::Type{Foo}) = (:bar, :baz, ...)\n\n# Another custom types\ncustom_field_names(::Type{Bar}) = (:data, ...)\ncustom_field_names(::Type{Baz}) = (:another_data, ...)\n\nSee also to_pretty_json.\n\nExamples\n\njulia> struct Pet\n           name::String\n           age::Int64\n       end\n\njulia> struct Person\n           info::Dict{String,Any}\n           pet::Pet\n       end\n\njulia> person_info = Dict(\"id\" => 42, \"marks\" => [\"A+\", \"B\", \"A\"]);\n\njulia> to_json(Person(person_info, Pet(\"Buddy\", 5))) |> print\n{\"info\":{\"marks\":[\"A+\",\"B\",\"A\"],\"id\":42},\"pet\":{\"name\":\"Buddy\",\"age\":5}}\n\nNow, lets select some specific fields from custom type\n\njulia> struct ManyFields\n           field::Int64\n           another_field::Float64\n           simple_field::String\n           fld::Vector{Bool}\n       end\n\njulia> custom_field_names(::Type{ManyFields}) = (:field, :simple_field)\n\njulia> to_json(custom_field_names, ManyFields(1, 2.0, \"a\", [true, false])) |> print\n{\"field\":1,\"simple_field\":\"a\"}\n\n# Or you can use a lambda function\n\njulia> to_json(x -> (:field, :simple_field), ManyFields(1, 2.0, \"a\", [true, false])) |> print\n{\"field\":1,\"simple_field\":\"a\"}\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serde.SerJson.to_pretty_json","page":"JSON","title":"Serde.SerJson.to_pretty_json","text":"to_pretty_json([f::Function], data) -> String\n\nDo the same as to_json but return pretty JSON string.\n\njulia> struct Pet\n           name::String\n           age::Int64\n       end\n\njulia> struct Person\n           info::Dict{String,Any}\n           pet::Pet\n       end\n\njulia> person_info = Dict(\"id\" => 42, \"marks\" => [\"A+\", \"B\", \"A\"]);\n\njulia> to_pretty_json(Person(person_info, Pet(\"Buddy\", 5))) |> print\n{\n  \"info\":{\n    \"marks\":[\n      \"A+\",\n      \"B\",\n      \"A\"\n    ],\n    \"id\":42\n  },\n  \"pet\":{\n    \"name\":\"Buddy\",\n    \"age\":5\n  }\n}\n\n\n\n\n\n","category":"function"},{"location":"pages/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"pages/utils/#Serde.to_flatten","page":"Utils","title":"Serde.to_flatten","text":"Serde.to_flatten(data; delimiter = \"_\") -> Dict{String, Any}\n\nTransforms a nested dictionary data (or custom type) into a single-level dictionary. The keys in the new dictionary are created by joining the nested keys (or fieldnames) with delimiter symbol.\n\nExamples\n\nFlatten the nested dictionary with custom delimiter symbol.\n\njulia> nested_dict = Dict(\n       \"foo\" => 1,\n       \"bar\" => Dict(\n           \"foo\" => 2,\n           \"baz\" => Dict(\n              \"foo\" => 3,\n               ),\n           ),\n       );\n\njulia> Serde.to_flatten(nested_dict; delimiter = \"__\")\nDict{String, Any} with 3 entries:\n  :bar__baz__foo => 3\n  :foo           => 1\n  :bar__foo      => 2\n\nFlatten the nested structure.\n\njulia> struct Bar\n           num::Float64\n       end\n\njulia> struct Foo\n           val::Int64\n           str::String\n           bar::Bar\n       end\n\njulia> nested_struct = Foo(1, \"a\", Bar(1.0));\n\njulia> Serde.to_flatten(nested_struct)\nDict{String, Any} with 3 entries:\n  :bar_num => 1.0\n  :val   => 1\n  :str   => \"a\"\n\n\n\n\n\n","category":"function"},{"location":"pages/utils/#Serde.@serde","page":"Utils","title":"Serde.@serde","text":"@serde decorators... typedef\n\nHelper macro that implements user friendly configuration of the (de)serialization process (see extended deserialization and serialization). Available decorators:\n\n@default_value: Used to define default values for fields of declared type (see Serde.default_value).\n@de_name: Used to defines an alias names for fields of declared type (see Serde.custom_name).\n@ser_name: Used to define custom output name for fields of declared type (see Serde.ser_name).\n\nNext, the syntax template looks like this:\n\n@serde @decor_1 @decor_2 ... struct\n    var::T | val_1 | val_2 | ...\n    ...\nend\n\nAny combination of available decorators is valid. Decorators must be placed between @serde and struct keyword. Decorator values belonging to a certain field must be separated by the | symbol.\n\nExamples\n\n@serde @default_value @de_name @ser_name mutable struct Foo\n    bar::Int64 | 1 | \"first\" | \"bar\"\n    baz::Int64 | 2 | \"baz\"   | \"second\"\nend\n\nIf we do not specify any value, it will be taken from the column corresponding to @default_value. Notice that bar was initialised with default 1.\n\njulia> deser_json(Foo, \"\"\"{\"baz\": 20}\"\"\")\nFoo(1, 20)\n\nAlso, now names from the @de_name column will be used for deserialization.\n\njulia> deser_json(Foo, \"\"\"{\"first\": 30}\"\"\")\nFoo(30, 2)\n\nNames from the @ser_name column will be used as output names for serialization.\n\njulia> to_json(Foo(40, 50)) |> print\n{\"bar\":40,\"second\":50}\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_pascal_case","page":"Utils","title":"Serde.@serde_pascal_case","text":"@serde_pascal_case T\n\nMarks all fields of type T with custom names corresponding to PascalCase.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           red_snake::Int64\n       end\n\njulia> @serde_pascal_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"RedSnake\" => 1))\nMySnakes(1)\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_camel_case","page":"Utils","title":"Serde.@serde_camel_case","text":"@serde_camel_case T\n\nMarks all fields of type T with custom names corresponding to camelCase.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           forest_snake::Int64\n       end\n\njulia> @serde_camel_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"forestSnake\" => 2))\nMySnakes(2)\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_kebab_case","page":"Utils","title":"Serde.@serde_kebab_case","text":"@serde_kebab_case T\n\nMarks all fields of type T with custom names corresponding to kebab-case.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           pretty_snake::Int64\n       end\n\njulia> @serde_kebab_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"pretty-snake\" => 3))\nMySnakes(3)\n\n\n\n\n\n","category":"macro"},{"location":"#Serde.jl","page":"Home","title":"Serde.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Serde is a Julia library for (de)serializing data to/from various formats. The library offers a simple and concise API for defining custom (de)serialization behavior for user-defined types. Inspired by the serde.rs Rust library, it supports the following data formats:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<html>\n  <body>\n    <table>\n      <tr><th>Format</th><th><div align=center>JSON</div></th><th><div align=center>TOML</div></th></tr>\n      <tr>\n        <td>Deserialization</td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n      </tr>\n      <tr>\n        <td>Serialization</td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n      </tr>\n    </table>\n  </body>\n</html>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Serde, simply use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Serde","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's look at some of the most used cases","category":"page"},{"location":"#Deserialization","page":"Home","title":"Deserialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following is an example of how you can deserialize various formats, like JSON, TOML, Query and CSV into a custom structure JuliaCon. The deserialization process was also modified to correctly process start_date and end_date by adding the method Serde.deser","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\nstruct JuliaCon\n    title::String\n    start_date::Date\n    end_date::Date\nend\n\nfunction Serde.deser(::Type{JuliaCon}, ::Type{Date}, v::String)\n    return Dates.Date(v, \"yyyy U d\")\nend\n\n# JSON deserialization\njson = \"\"\"\n{\n  \"title\": \"JuliaCon 2024\",\n  \"start_date\": \"2024 July 9\",\n  \"end_date\": \"2024 July 13\"\n}\n\"\"\"\n\njulia> juliacon = deser_json(JuliaCon, json)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# TOML deserialization\ntoml = \"\"\"\ntitle = \"JuliaCon 2024\"\nstart_date = \"2024 July 9\"\nend_date = \"2024 July 13\"\n\"\"\"\n\njulia> juliacon = deser_toml(JuliaCon, toml)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to see more deserialization options, then take a look at the corresponding section of the documentation","category":"page"},{"location":"#Serialization","page":"Home","title":"Serialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example shows how an object juliacon of custom type JuliaCon can be serialized into various formats, like JSON, TOML, XML, etc. In that case, all dates will be correctly converted into strings of the required format by overloaded function ser_type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\nstruct JuliaCon\n    title::String\n    start_date::Date\n    end_date::Date\nend\n\njuliacon = JuliaCon(\"JuliaCon 2024\", Date(2024, 7, 9), Date(2024, 7, 13))\n\n# JSON serialization\nfunction Serde.SerJson.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"yyyy U d\")\nend\n\njulia> to_json(juliacon) |> print\n{\"title\":\"JuliaCon 2024\",\"start_date\":\"2024 July 9\",\"end_date\":\"2024 July 13\"}\n\n# TOML serialization\nfunction Serde.SerToml.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"yyyy-mm-dd\")\nend\n\njulia> to_toml(juliacon) |> print\ntitle = \"JuliaCon 2024\"\nstart_date = \"2024-07-09\"\nend_date = \"2024-07-13\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to see more serialization options, then take a look at the corresponding section of the documentation","category":"page"},{"location":"#User-friendly-(de)serialization","page":"Home","title":"User-friendly (de)serialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"That's not all, work is currently underway on macro functionality that allows for more fine-grained and simpler customization of the (de)serialization process. You can choose from various available decorators that will allow you to unleash all the possibilities of Serde. For more details, check the documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\n@serde @default_value @de_name struct JuliaCon\n    title::String    | \"JuliaCon 2024\"   | \"title\"\n    start_date::Date | nothing           | \"start\"\n    end_date::Date   | Date(2024, 7, 24) | \"end\"\nend\n\nfunction Serde.deser(::Type{JuliaCon}, ::Type{Date}, v::String)\n    return Dates.Date(v)\nend\n\njson = \"\"\"{\"title\": \"JuliaCon 2024\", \"start\": \"2024-07-22\"}\"\"\"\n\njulia> juliacon = deser_json(JuliaCon, json)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-22\"), Date(\"2024-07-24\"))\n\njulia> to_json(juliacon) |> print\n{\"title\":\"JuliaCon 2024\",\"start_date\":\"2024-07-22\",\"end_date\":\"2024-07-24\"}","category":"page"},{"location":"pages/extended_de/#ex_deser","page":"Extended deserialization","title":"Extended deserialization","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.jl allows users to define how their custom data will be processed during deserialization.","category":"page"},{"location":"pages/extended_de/#Serde.deser-Tuple{Type, Any}","page":"Extended deserialization","title":"Serde.deser","text":"Serde.deser(::Type{T}, data) -> T\n\nMain function of this module which can construct an object of type T from another object data. Can deserialize complex object with a deep nesting.\n\nFunction deser supports:\n\nDeserialization from Dict and Vector to Struct\nDeserialization from Dict and Vector to Vector of Struct\nDeserialization from Dict to Dict\nTypecasting during deserialization\nDefault value for struct arguments (see Serde.default_value)\nCustom name for struct arguments (see Serde.custom_name)\nEmpty type definition (see Serde.isempty)\nDeserializing missing and nothing (see Serde.nulltype)\n\nExamples:\n\njulia> struct Info\n           id::Int64\n           salary::Int64\n       end\n\njulia> struct Person\n           name::String\n           age::Int64\n           info::Info\n       end\n\njulia> info_data = Dict(\"id\" => 12, \"salary\" => 2500);\n\njulia> person_data = Dict(\"name\" => \"Michael\", \"age\" => 25, \"info\" => info_data);\n\njulia> Serde.deser(Person, person_data)\nPerson(\"Michael\", 25, Info(12, 2500))\n\n\n\n\n\n","category":"method"},{"location":"pages/extended_de/#Custom-deserialization-behavior","page":"Extended deserialization","title":"Custom deserialization behavior","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"If you need to deserialize non-standard custom data types, it will be useful to define a behavior to handle them.","category":"page"},{"location":"pages/extended_de/#Serde.deser-Tuple{Type, Type, Any}","page":"Extended deserialization","title":"Serde.deser","text":"Serde.deser(::Type{T}, ::Type{E}, data::D) -> E\n\nInternal function that is used to deserialize data to fields with type E of custom type T. Supports user overriding for custom types.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nExamples:\n\nLet's make a custom type Order with fields price and date.\n\nusing Dates\n\nstruct Order\n    price::Int64\n    date::DateTime\nend\n\nNow, we define a new method Serde.deser for the custom type Order. This method will be called for each field of Order that is of type DateTime and has been passed a String value.\n\nfunction Serde.deser(\n    ::Type{T},\n    ::Type{E},\n    x::String\n)::E where {T<:Order,E<:DateTime}\n    return DateTime(x)\nend\n\nAfter that, if we try to deserialize a dictionary that has a key date with a String value, it will correctly convert the String to a DateTime value.\n\njulia> Serde.deser(Order, Dict(\"price\" => 1000, \"date\" => \"2024-01-01T10:20:30\"))\nOrder(1000, DateTime(\"2024-01-01T10:20:30\"))\n\n\n\n\n\n","category":"method"},{"location":"pages/extended_de/#Empty-values-handling","page":"Extended deserialization","title":"Empty values handling","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"We can also determine which data types and their values will be treated as nothing.","category":"page"},{"location":"pages/extended_de/#Base.isempty","page":"Extended deserialization","title":"Base.isempty","text":"Serde.isempty(::Type{T}, x) -> false\n\nThis function determines the condition under which the passed value x for some custom type T can be treated as nothing. Supports user overriding for custom types. Initially, all values are set to false.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.nulltype, Serde.default_value, Serde.isignored_name.\n\nExamples:\n\nLet's make a custom type Computer with the following fields. The gpu field may be either a String or Nothing.\n\nstruct Computer\n    cpu::String\n    ram::Int64\n    gpu::Union{Nothing,String}\nend\n\nNow, we define a new method Serde.isempty for the custom type Computer. This method will be called for each field of Computer that has been passed a String value.\n\nfunction Serde.isempty(::Type{Computer}, x::String)\n    return x == \"\"\nend\n\nSo, if we try to deserialize a dictionary with a key gpu containing an empty string, it will set a nothing value for such a field in Computer.\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i7-12900\", \"ram\" => 32, \"gpu\" => \"rtx-4090\"))\nComputer(\"i7-12900\", 32, \"rtx-4090\")\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i3-12100\", \"ram\" => 16, \"gpu\" => \"\"))\nComputer(\"i3-12100\", 16, nothing)\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Names-aliases","page":"Extended deserialization","title":"Names aliases","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Sometimes, the field names of the incoming data structure differ from their intended destination. In this case, it is convenient to specify name aliases.","category":"page"},{"location":"pages/extended_de/#Serde.custom_name","page":"Extended deserialization","title":"Serde.custom_name","text":"Serde.custom_name(::Type{T}, ::Val{x}) -> x\n\nThis function is used to define an alias name for field x of type T. Supports user overriding for custom types. Initially, all passed names must be equivalent to the target names. Methods of this function must return a Symbol or a String value.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nExamples:\n\nLet's make a custom type Phone with one field price.\n\nstruct Phone\n    price::Int64\nend\n\nNow, we can define a new method Serde.custom_name for the type Phone and its field price.\n\nfunction Serde.custom_name(::Type{Phone}, ::Val{:price})\n    return \"cost\"\nend\n\nAfter that, if we try to deserialize a dictionary with an alias key \"cost\", it will match with the field price of type Phone.\n\njulia> Serde.deser(Phone, Dict(\"cost\" => 1000))\nPhone(1000)\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Custom-default-values","page":"Extended deserialization","title":"Custom default values","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"We can also define default values for certain data types.","category":"page"},{"location":"pages/extended_de/#Serde.default_value","page":"Extended deserialization","title":"Serde.default_value","text":"Serde.default_value(::Type{T}, ::Val{x}) -> nothing\n\nThis function is used to define default values for field x of type T. Supports user overriding for custom types. Initially, all values are set to nothing.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.isempty, Serde.nulltype, Serde.isignored_name.\n\nExamples:\n\nLet's make a custom type TimeZone with the field gmt.\n\nstruct TimeZone\n    gmt::String\nend\n\nNow, we can define a new method Serde.default_value for the type TimeZone and its field gmt.\n\nfunction Serde.default_value(::Type{TimeZone}, ::Val{:gmt})\n    return \"UTC+3\"\nend\n\nAfter that, if we try to deserialize a dictionary without a key gmt, it will be filled with the default value \"UTC+3\".\n\njulia> Serde.deser(TimeZone, Dict{String,Any}())\nTimeZone(\"UTC+3\")\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Null-types-handling","page":"Extended deserialization","title":"Null types handling","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"We can also determine the 'nulltype' for custom types when they are empty or not specified at all.","category":"page"},{"location":"pages/extended_de/#Serde.nulltype","page":"Extended deserialization","title":"Serde.nulltype","text":"Serde.nulltype(::Type{T}) -> nothing\n\nDefines behavior when the value for a field of type T is empty (according to Serde.isempty) or not specified. Supports user overriding for custom types. Initially, for all types, it is set to nothing (in case of type Missing, it returns the missing value).\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.isempty, Serde.default_value, Serde.isignored_name.\n\nExamples\n\nLet's make a custom type Computer with the following fields.\n\nstruct Computer\n    cpu::String\n    gpu::String\nend\n\nFor clarity, we also define the Serde.isempty method.\n\nSerde.isempty(::Type{Computer}, x::String) = x == \"\"\n\nNext, we define a new method Serde.nulltype for the custom type Computer. This method will be called for each type String that has been passed to a Serde.deser method.\n\nSerde.nulltype(::Type{String}) = \"N/A\"\n\nAnd, if we try to deserialize a dictionary with values of type String containing an empty string or not specified at all, it will set a \"N/A\" value for such fields in Computer.\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i7-12900\", \"gpu\" => \"\"))\nComputer(\"i7-12900\", \"N/A\")\n\njulia> Serde.deser(Computer, Dict{String,Any}())\nComputer(\"N/A\", \"N/A\")\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Ignore-fields","page":"Extended deserialization","title":"Ignore fields","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Finally, we can specify which fields should be ignored during deserialization.","category":"page"},{"location":"pages/extended_de/#Serde.isignored_name","page":"Extended deserialization","title":"Serde.isignored_name","text":"Serde.isignored_name(::Type{T}, ::Val{x}) -> false\n\nThis function allows to mark a field x for some custom type T as ignored for deserialization. Supports user overriding for custom types. Initially, all field names are set to false.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.nulltype, Serde.default_value, Serde.isempty.\n\nExamples:\n\nLet's make a custom type Computer with the following fields and constructor.\n\nstruct Computer\n    cpu::String\n    ram::Int64\n    info::String\nend\n\nfunction Computer(cpu::String, ram::Int64)\n    return Computer(cpu, ram, string(\"cpu: \", cpu, \" ram: \", ram))\nend\n\nNow, we define a new method Serde.isignored_name for the custom type Computer. This method will be called for each field of Computer.\n\nfunction Serde.isignored_name(::Type{Computer}, ::Val{:info})\n    return true\nend\n\nSo, if we try to deserialize a dictionary with two keys into a custom type Computer with three fields, it will call the constructor that takes two arguments.\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i7-12700H\", \"ram\" => 32))\nComputer(\"i7-12700H\", 32, \"cpu: i7-12700H ram: 32\")\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_ser/#ex_ser","page":"Extended serialization","title":"Extended serialization","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Serde.jl users have the flexibility to customize the serialization process of their data.","category":"page"},{"location":"pages/extended_ser/#ser_name","page":"Extended serialization","title":"Changing output names","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"If you want to change the output names of your custom type, you just have to extend the Serde.<SubModule>.ser_name function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The return value of your method must be of type Symbol or String. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_name(::Type{T}, ::Val{x})::Symbol where {T,x} = x","category":"page"},{"location":"pages/extended_ser/#Example","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Ticket.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Ticket\n    cost::Int64\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, we can add a new method SerJson.ser_name for the custom type Ticket and its field cost.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ser_name(::Type{Ticket}, ::Val{:cost}) = :price","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"After that, in the resulting JSON string the field cost will become price.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(Ticket(1000)) |> print\n{\"price\":1000}","category":"page"},{"location":"pages/extended_ser/#Handling-field-values","page":"Extended serialization","title":"Handling field values","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Also, we can specify how to process certain fields of custom types. In that case, you need extend the Serde.<SubModule>.ser_value function. This approach is supported by such serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The method can return a value of any type. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_value(::Type{T}, ::Val{x}, v::V) where {T,x,V} = v","category":"page"},{"location":"pages/extended_ser/#Example-2","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Dates\nusing Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Calendar.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct JuliaBirthday\n    date::DateTime\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"In the next line, we add a method SerJson.ser_value for the custom type JuliaBirthday and its field date of type DateTime.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"function SerJson.ser_value(::Type{JuliaBirthday}, ::Val{:date}, v::DateTime)\n    return Dates.value(Nanosecond(datetime2unix(v)))\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, we will obtain a nanosecond value of the field v.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(JuliaBirthday(DateTime(2012, 2, 14))) |> print\n{\"date\":1329177600}","category":"page"},{"location":"pages/extended_ser/#Handling-values-of-specific-types","page":"Extended serialization","title":"Handling values of specific types","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"If you want to override how to serialize a specific type, you need extend the Serde.<SubModule>.ser_type function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The method can return a value of any type. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_type(::Type{T}, v::V) where {T,V} = v","category":"page"},{"location":"pages/extended_ser/#Example-3","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Computer with two string fields.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Computer\n    cpu::String\n    gpu::String\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"As well, we can add a method SerJson.ser_type for type Computer and all its fields of type String.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ser_type(::Type{Computer}, v::String) = uppercase(v)","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, every string field of Computer will be in uppercase.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(Computer(\"i7-12900\", \"rtx-4090\")) |> print\n{\"cpu\":\"I7-12900\",\"gpu\":\"RTX-4090\"}","category":"page"},{"location":"pages/extended_ser/#Ignoring-fields","page":"Extended serialization","title":"Ignoring fields","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Finally, we can specify what fields must be ignored. In this case, you just need to extend the Serde.<SubModule>.ignore_field function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The return value of your method must be of type Bool. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ignore_field(::Type{T}, ::Val{x})::Bool where {T,x} = false","category":"page"},{"location":"pages/extended_ser/#Example-4","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Box.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Box\n    height::Int64\n    width::Int64\n    length::Int64\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Let's add the SerJson.ignore_field method for type Box.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ignore_field(::Type{Box}, ::Val{:length}) = true","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Because the field length is ignorable, the resulting JSON string contains only height and width values.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json(Box(2, 5, 6)) |> print\n{\"height\":2,\"width\":5}","category":"page"}]
}
